# keenbot
Serverless chatbot app for testing, partially generated by LLMs

## Setup

```
keenbot$ python -m venv venv

keenbot$ venv\Scripts\activate

keenbot$ pip install -r requirements.txt

keenbot$ streamlit run src/keenbot.py
```

## Chat Comment History
~You are a web development expert, but you take your time to think about simple and elegant solutions to app architecture.
Provide the code for a serverless chatbot application using AWS Bedrock with Claude 3.5 Sonnet and the Streamlit Python library.
The app should have the ability to label a conversation thread using a text box input, but that text box value should be selectable from a prior chat list or a new chat with new label may be given.
Also, the session_state of the streamlit environment should be stored as a file and updated with each user request and app response. The conversation-specific state should be reloaded when the conversation thread is selected in the text box input.~

Here's a simple and elegant solution for a serverless chatbot application using AWS Bedrock with Claude 3.5 Sonnet and the Streamlit Python library. This solution incorporates conversation labeling, chat history, and session state management.

```python
import streamlit as st
import boto3
import json
import os

# Initialize AWS Bedrock client
bedrock = boto3.client(service_name='bedrock-runtime')

# Function to get response from Claude
def get_claude_response(prompt, conversation_history):
    body = json.dumps({
        "prompt": f"\n\nHuman: {prompt}\n\nAssistant: ",
        "max_tokens_to_sample": 500,
        "temperature": 0.7,
        "stop_sequences": ["\n\nHuman:"]
    })

    response = bedrock.invoke_model(
        body=body,
        modelId="anthropic.claude-3-sonnet-20240229-v1:0",
        contentType="application/json"
    )
    
    response_body = json.loads(response.get('body').read())
    return response_body.get('completion', '').strip()

# Function to save session state
def save_session_state(filename):
    with open(filename, 'w') as f:
        json.dump(dict(st.session_state), f)

# Function to load session state
def load_session_state(filename):
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            return json.load(f)
    return {}

# Initialize session state
if 'conversations' not in st.session_state:
    st.session_state.conversations = {}

if 'current_conversation' not in st.session_state:
    st.session_state.current_conversation = 'New Chat'

# Sidebar for conversation selection
st.sidebar.title("Conversations")

# Text input for new conversation label
new_conversation = st.sidebar.text_input("New conversation label")

if new_conversation and new_conversation not in st.session_state.conversations:
    st.session_state.conversations[new_conversation] = []
    st.session_state.current_conversation = new_conversation

# Selectbox for existing conversations
conversation_labels = list(st.session_state.conversations.keys())
conversation_labels.insert(0, "New Chat")
selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_labels)

if selected_conversation != st.session_state.current_conversation:
    st.session_state.current_conversation = selected_conversation
    if selected_conversation != "New Chat":
        # Load conversation-specific state
        state_filename = f"{selected_conversation.replace(' ', '_').lower()}_state.json"
        loaded_state = load_session_state(state_filename)
        st.session_state.update(loaded_state)

# Main chat interface
st.title("Claude 3.5 Sonnet Chatbot")

# Display conversation history
if st.session_state.current_conversation in st.session_state.conversations:
    for message in st.session_state.conversations[st.session_state.current_conversation]:
        with st.chat_message(message["role"]):
            st.write(message["content"])

# Chat input
user_input = st.chat_input("Type your message here...")

if user_input:
    # Display user message
    with st.chat_message("user"):
        st.write(user_input)

    # Get Claude's response
    conversation_history = st.session_state.conversations.get(st.session_state.current_conversation, [])
    claude_response = get_claude_response(user_input, conversation_history)

    # Display Claude's response
    with st.chat_message("assistant"):
        st.write(claude_response)

    # Update conversation history
    if st.session_state.current_conversation not in st.session_state.conversations:
        st.session_state.conversations[st.session_state.current_conversation] = []
    
    st.session_state.conversations[st.session_state.current_conversation].extend([
        {"role": "user", "content": user_input},
        {"role": "assistant", "content": claude_response}
    ])

    # Save session state
    state_filename = f"{st.session_state.current_conversation.replace(' ', '_').lower()}_state.json"
    save_session_state(state_filename)

# Run the Streamlit app
if __name__ == "__main__":
    st.run()
```

This code provides a serverless chatbot application using AWS Bedrock with Claude 3.5 Sonnet and the Streamlit Python library. Here's a breakdown of the main components:

1. AWS Bedrock Integration: The application uses boto3 to interact with AWS Bedrock and invoke the Claude 3.5 Sonnet model.

2. Conversation Management: Users can create new conversations or select existing ones from a sidebar. Each conversation is labeled and stored separately.

3. Session State Management: The application uses Streamlit's session_state to manage conversation history and app state. The state is saved to and loaded from JSON files for each conversation.

4. Chat Interface: The main interface displays the conversation history and allows users to input new messages.

5. Response Generation: When a user sends a message, the application gets a response from Claude using the AWS Bedrock API.

6. State Persistence: The application saves the session state after each interaction, allowing users to resume conversations later.

To run this application, you'll need to:

1. Install the required libraries: streamlit and boto3.
2. Set up AWS credentials with access to Bedrock.
3. Run the script using `streamlit run your_script_name.py`.

This solution provides a simple yet powerful architecture for a serverless chatbot application. It's easily extensible and can be further improved with additional features like error handling, user authentication, and more advanced conversation management.

Would you like me to explain or break down any specific part of the code?

~You are a web development expert, but you take your time to think about simple and elegant solutions to app architecture.
Provide the code for a serverless chatbot application using AWS Bedrock with Claude 3.5 Sonnet and the Streamlit Python library.
The app should have the ability to label a conversation thread using a text box input, but that text box value should be selectable from a prior chat list or a new chat with new label may be given.
Also, the session_state of the streamlit environment should be stored as a file and updated with each user request and app response. The conversation-specific state should be reloaded when the conversation thread is selected in the text box input.~

Certainly. I'll modify the program to include LangChain for memory management. In this case, we'll use LangChain's memory components to handle conversation history, which will simplify our code and provide more robust memory management. We'll keep the conversation labeling and selection features, but use LangChain's export and import features for storing and loading conversations.

Here's the modified version of the code:

```python
import streamlit as st
import boto3
import json
import os
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Initialize Bedrock LLM
llm = Bedrock(
    model_id="anthropic.claude-3-sonnet-20240229-v1:0",
    client=bedrock_client,
    model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
)

# Custom prompt template
prompt_template = """The following is a friendly conversation between a human and an AI assistant named Claude. Claude is helpful, creative, clever, and very friendly.

Current conversation:
{history}
Human: {input}
Claude:"""

PROMPT = PromptTemplate(
    input_variables=["history", "input"], template=prompt_template
)

# Initialize session state
if 'conversations' not in st.session_state:
    st.session_state.conversations = {}

if 'current_conversation' not in st.session_state:
    st.session_state.current_conversation = 'New Chat'

# Function to create a new conversation chain
def create_conversation_chain():
    memory = ConversationBufferMemory(return_messages=True)
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Sidebar for conversation selection
st.sidebar.title("Conversations")

# Text input for new conversation label
new_conversation = st.sidebar.text_input("New conversation label")

if new_conversation and new_conversation not in st.session_state.conversations:
    st.session_state.conversations[new_conversation] = create_conversation_chain()
    st.session_state.current_conversation = new_conversation

# Selectbox for existing conversations
conversation_labels = list(st.session_state.conversations.keys())
conversation_labels.insert(0, "New Chat")
selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_labels)

if selected_conversation != st.session_state.current_conversation:
    st.session_state.current_conversation = selected_conversation
    if selected_conversation != "New Chat":
        if selected_conversation not in st.session_state.conversations:
            # Load conversation from file
            filename = f"{selected_conversation.replace(' ', '_').lower()}_conversation.json"
            if os.path.exists(filename):
                with open(filename, 'r') as f:
                    saved_memory = json.load(f)
                new_chain = create_conversation_chain()
                new_chain.memory.chat_memory.messages = saved_memory
                st.session_state.conversations[selected_conversation] = new_chain
            else:
                st.session_state.conversations[selected_conversation] = create_conversation_chain()

# Main chat interface
st.title("Claude 3.5 Sonnet Chatbot")

# Display conversation history
if st.session_state.current_conversation in st.session_state.conversations:
    chain = st.session_state.conversations[st.session_state.current_conversation]
    for message in chain.memory.chat_memory.messages:
        with st.chat_message(message.type):
            st.write(message.content)

# Chat input
user_input = st.chat_input("Type your message here...")

if user_input:
    # Get or create conversation chain
    if st.session_state.current_conversation not in st.session_state.conversations:
        st.session_state.conversations[st.session_state.current_conversation] = create_conversation_chain()
    
    chain = st.session_state.conversations[st.session_state.current_conversation]
    
    # Get Claude's response
    response = chain.predict(input=user_input)

    # Display user message and Claude's response
    with st.chat_message("human"):
        st.write(user_input)
    with st.chat_message("ai"):
        st.write(response)

    # Save conversation to file
    filename = f"{st.session_state.current_conversation.replace(' ', '_').lower()}_conversation.json"
    with open(filename, 'w') as f:
        json.dump(chain.memory.chat_memory.messages, f, default=lambda x: x.__dict__)

# Run the Streamlit app
if __name__ == "__main__":
    st.run()
```

This modified version of the code incorporates LangChain for memory management and conversation handling. Here are the key changes and benefits:

1. LangChain Integration: We're now using LangChain's `ConversationBufferMemory` and `ConversationChain` to manage conversation history and generate responses.

2. Bedrock LLM: We've integrated the Bedrock LLM directly with LangChain, which simplifies the interaction with Claude 3.5 Sonnet.

3. Conversation Management: Each conversation is now an instance of `ConversationChain`, which handles its own memory and state.

4. Memory Persistence: We're using LangChain's memory export feature to save conversations to JSON files. This allows us to easily load and resume conversations.

5. Simplified State Management: By leveraging LangChain's built-in memory management, we've simplified our state handling code.

6. Custom Prompt: We've added a custom prompt template to ensure consistent conversation format and AI behavior.

Benefits of this approach:

1. More robust memory management: LangChain's memory components are designed specifically for managing conversation history with language models.

2. Easier integration with other LangChain features: If you want to add more advanced features in the future (like summarization, vector stores, or multi-model chains), it will be easier to integrate them.

3. Simplified code: The core logic for managing conversations and generating responses is now handled by LangChain, making our code cleaner and more focused on the application-specific logic.

4. Consistent conversation format: The custom prompt template ensures that all conversations follow the same format, which can lead to more consistent AI responses.

This version of the code maintains the same functionality as the previous version but leverages LangChain's capabilities for a more robust and extensible solution. The conversation save and load features now use LangChain's memory export and import features, which simplifies our state management while providing the same benefits.

Would you like me to explain any specific part of this updated code?

~Instead of saving the messages to json file, create a SQLite database with at least the following columns: conversation_id (int), conversation name (string), message_id (int), message (string, serialized from langchain chat message history).
Add any columns that may be useful to be independently stored to the database from conversation metadata. Please include serialization and deserialization functions for converting langchain chat history messages to strings and returning those messages from strings, respectively. The langchain data may require care to adjust formats to Python pickle-able or serializable formats, so take your time to get that right.~

Certainly. I'll modify the program to use a SQLite database for storing conversations and messages, including serialization and deserialization functions for LangChain chat history messages. Here's the updated version of the code:

```python
import streamlit as st
import boto3
import json
import os
import sqlite3
import pickle
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage
from datetime import datetime

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Initialize Bedrock LLM
llm = Bedrock(
    model_id="anthropic.claude-3-sonnet-20240229-v1:0",
    client=bedrock_client,
    model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
)

# Custom prompt template
prompt_template = """The following is a friendly conversation between a human and an AI assistant named Claude. Claude is helpful, creative, clever, and very friendly.

Current conversation:
{history}
Human: {input}
Claude:"""

PROMPT = PromptTemplate(
    input_variables=["history", "input"], template=prompt_template
)

# Initialize SQLite database
def init_db():
    conn = sqlite3.connect('chatbot.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  message TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations (id))''')
    conn.commit()
    conn.close()

# Serialization function
def serialize_message(message):
    return pickle.dumps(message)

# Deserialization function
def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation
def create_conversation(name):
    conn = sqlite3.connect('chatbot.db')
    c = conn.cursor()
    c.execute("INSERT INTO conversations (name) VALUES (?)", (name,))
    conversation_id = c.lastrowid
    conn.commit()
    conn.close()
    return conversation_id

# Function to save a message
def save_message(conversation_id, message):
    conn = sqlite3.connect('chatbot.db')
    c = conn.cursor()
    serialized_message = serialize_message(message)
    c.execute("INSERT INTO messages (conversation_id, message) VALUES (?, ?)",
              (conversation_id, serialized_message))
    conn.commit()
    conn.close()

# Function to load messages for a conversation
def load_messages(conversation_id):
    conn = sqlite3.connect('chatbot.db')
    c = conn.cursor()
    c.execute("SELECT message FROM messages WHERE conversation_id = ? ORDER BY created_at", (conversation_id,))
    messages = [deserialize_message(row[0]) for row in c.fetchall()]
    conn.close()
    return messages

# Function to get all conversations
def get_conversations():
    conn = sqlite3.connect('chatbot.db')
    c = conn.cursor()
    c.execute("SELECT id, name FROM conversations ORDER BY created_at DESC")
    conversations = c.fetchall()
    conn.close()
    return conversations

# Function to create a new conversation chain
def create_conversation_chain(conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conversation_id)
        memory.chat_memory.messages = messages
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Initialize database
init_db()

# Initialize session state
if 'current_conversation' not in st.session_state:
    st.session_state.current_conversation = None

# Sidebar for conversation selection
st.sidebar.title("Conversations")

# Text input for new conversation label
new_conversation = st.sidebar.text_input("New conversation label")

if new_conversation:
    conversation_id = create_conversation(new_conversation)
    st.session_state.current_conversation = conversation_id

# Selectbox for existing conversations
conversations = get_conversations()
conversation_options = ["New Chat"] + [f"{id}: {name}" for id, name in conversations]
selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

if selected_conversation != "New Chat":
    conversation_id = int(selected_conversation.split(":")[0])
    if st.session_state.current_conversation != conversation_id:
        st.session_state.current_conversation = conversation_id

# Main chat interface
st.title("Claude 3.5 Sonnet Chatbot")

# Display conversation history
if st.session_state.current_conversation:
    chain = create_conversation_chain(st.session_state.current_conversation)
    for message in chain.memory.chat_memory.messages:
        with st.chat_message(message.type):
            st.write(message.content)

# Chat input
user_input = st.chat_input("Type your message here...")

if user_input:
    # Get or create conversation chain
    if not st.session_state.current_conversation:
        conversation_id = create_conversation("New Chat")
        st.session_state.current_conversation = conversation_id
    
    chain = create_conversation_chain(st.session_state.current_conversation)
    
    # Get Claude's response
    response = chain.predict(input=user_input)

    # Display user message and Claude's response
    with st.chat_message("human"):
        st.write(user_input)
    with st.chat_message("ai"):
        st.write(response)

    # Save messages to database
    save_message(st.session_state.current_conversation, HumanMessage(content=user_input))
    save_message(st.session_state.current_conversation, AIMessage(content=response))

# Run the Streamlit app
if __name__ == "__main__":
    st.run()
```

This updated version of the code uses a SQLite database to store conversations and messages. Here are the key changes and additions:

1. SQLite Database: We've added functions to initialize the database (`init_db`), create conversations (`create_conversation`), save messages (`save_message`), load messages (`load_messages`), and get all conversations (`get_conversations`).

2. Serialization and Deserialization: We've added `serialize_message` and `deserialize_message` functions that use Python's `pickle` module to convert LangChain message objects to strings and vice versa. This allows us to store the full message objects in the database.

3. Database Schema: The database has two tables:
   - `conversations`: Stores conversation metadata (id, name, creation timestamp)
   - `messages`: Stores individual messages (id, conversation_id, serialized message, creation timestamp)

4. Conversation Management: Instead of using a dictionary in the session state, we now use the database to store and retrieve conversations.

5. Message Persistence: Messages are now saved to the database after each interaction, and loaded when a conversation is selected.

6. Conversation Selection: The sidebar now displays a list of all conversations from the database, allowing users to switch between them.

This implementation provides several benefits:

1. Persistent Storage: All conversations and messages are now stored in a SQLite database, ensuring data persistence across sessions.

2. Scalability: The database approach can handle a large number of conversations and messages more efficiently than storing everything in memory or individual files.

3. Easy Querying: With the data in a SQLite database, it's easy to add features like searching conversations or analyzing message history.

4. Full Message Object Storage: By serializing the entire message objects, we preserve all the metadata and structure of the LangChain messages.

Note that this implementation uses Python's `pickle` module for serialization, which is generally safe for this use case where you control both the serialization and deserialization. However, be cautious about using pickled data from untrusted sources, as it can pose security risks.

Would you like me to explain any specific part of this updated code or elaborate on any of the changes?

~If it would be better to reuse the database connection made once in the program, please rewrite the functions to use the connection as an input and setup that connection once in the main program. If it would not be better to reuse that database connection, please explain why.~

You're right to consider this. In most cases, reusing a database connection is indeed better for performance and resource management. Let's modify the code to use a single database connection throughout the program. Here's the updated version:

```python
import streamlit as st
import boto3
import json
import os
import sqlite3
import pickle
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage
from datetime import datetime

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Initialize Bedrock LLM
llm = Bedrock(
    model_id="anthropic.claude-3-sonnet-20240229-v1:0",
    client=bedrock_client,
    model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
)

# Custom prompt template
prompt_template = """The following is a friendly conversation between a human and an AI assistant named Claude. Claude is helpful, creative, clever, and very friendly.

Current conversation:
{history}
Human: {input}
Claude:"""

PROMPT = PromptTemplate(
    input_variables=["history", "input"], template=prompt_template
)

# Initialize SQLite database
def init_db(conn):
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  message TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations (id))''')
    conn.commit()

# Serialization function
def serialize_message(message):
    return pickle.dumps(message)

# Deserialization function
def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation
def create_conversation(conn, name):
    c = conn.cursor()
    c.execute("INSERT INTO conversations (name) VALUES (?)", (name,))
    conversation_id = c.lastrowid
    conn.commit()
    return conversation_id

# Function to save a message
def save_message(conn, conversation_id, message):
    c = conn.cursor()
    serialized_message = serialize_message(message)
    c.execute("INSERT INTO messages (conversation_id, message) VALUES (?, ?)",
              (conversation_id, serialized_message))
    conn.commit()

# Function to load messages for a conversation
def load_messages(conn, conversation_id):
    c = conn.cursor()
    c.execute("SELECT message FROM messages WHERE conversation_id = ? ORDER BY created_at", (conversation_id,))
    messages = [deserialize_message(row[0]) for row in c.fetchall()]
    return messages

# Function to get all conversations
def get_conversations(conn):
    c = conn.cursor()
    c.execute("SELECT id, name FROM conversations ORDER BY created_at DESC")
    conversations = c.fetchall()
    return conversations

# Function to create a new conversation chain
def create_conversation_chain(conn, conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conn, conversation_id)
        memory.chat_memory.messages = messages
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Main Streamlit app
def main():
    # Create a single database connection
    conn = sqlite3.connect('chatbot.db', check_same_thread=False)
    
    # Initialize database
    init_db(conn)

    # Initialize session state
    if 'current_conversation' not in st.session_state:
        st.session_state.current_conversation = None

    # Sidebar for conversation selection
    st.sidebar.title("Conversations")

    # Text input for new conversation label
    new_conversation = st.sidebar.text_input("New conversation label")

    if new_conversation:
        conversation_id = create_conversation(conn, new_conversation)
        st.session_state.current_conversation = conversation_id

    # Selectbox for existing conversations
    conversations = get_conversations(conn)
    conversation_options = ["New Chat"] + [f"{id}: {name}" for id, name in conversations]
    selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

    if selected_conversation != "New Chat":
        conversation_id = int(selected_conversation.split(":")[0])
        if st.session_state.current_conversation != conversation_id:
            st.session_state.current_conversation = conversation_id

    # Main chat interface
    st.title("Claude 3.5 Sonnet Chatbot")

    # Display conversation history
    if st.session_state.current_conversation:
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        for message in chain.memory.chat_memory.messages:
            with st.chat_message(message.type):
                st.write(message.content)

    # Chat input
    user_input = st.chat_input("Type your message here...")

    if user_input:
        # Get or create conversation chain
        if not st.session_state.current_conversation:
            conversation_id = create_conversation(conn, "New Chat")
            st.session_state.current_conversation = conversation_id
        
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        
        # Get Claude's response
        response = chain.predict(input=user_input)

        # Display user message and Claude's response
        with st.chat_message("human"):
            st.write(user_input)
        with st.chat_message("ai"):
            st.write(response)

        # Save messages to database
        save_message(conn, st.session_state.current_conversation, HumanMessage(content=user_input))
        save_message(conn, st.session_state.current_conversation, AIMessage(content=response))

    # Close the database connection when the app is done
    conn.close()

# Run the Streamlit app
if __name__ == "__main__":
    main()
```

In this updated version, we've made the following changes:

1. We create a single database connection at the beginning of the `main()` function.
2. All database-related functions now take the `conn` (connection) as a parameter.
3. We pass this connection to all function calls that interact with the database.
4. We close the connection at the end of the `main()` function.

Reusing the database connection is better for several reasons:

1. Performance: Opening and closing database connections is a relatively expensive operation. By reusing a single connection, we avoid this overhead for each database operation.

2. Resource Management: Database connections are limited resources. Reusing a single connection ensures we're not unnecessarily consuming these resources.

3. Transaction Management: Using a single connection makes it easier to manage transactions across multiple operations if needed.

4. Consistency: A single connection ensures that all operations within a session are seeing a consistent state of the database.

However, there are a couple of things to note:

1. We use `check_same_thread=False` when creating the SQLite connection. This is necessary because Streamlit runs in a multi-threaded environment, and SQLite connections are not thread-safe by default. In a production environment with higher concurrency, you might want to consider using a connection pool or a more robust database system.

2. We're still opening and closing the connection for each Streamlit run. In a more complex application, you might want to consider keeping the connection open across multiple runs, but this would require careful management of the connection lifecycle.

This approach provides a good balance between efficiency and simplicity for a Streamlit application. It reuses the connection within each run of the app, which covers most use cases, while still ensuring that connections are properly closed between runs.

~Add the ability to set the Claude system prompt when creating a new conversation. Include that prompt in the database table for storing conversation information.~

Certainly. I'll modify the code to allow setting a custom system prompt for each conversation and store it in the database. Here's the updated version:

```python
import streamlit as st
import boto3
import sqlite3
import pickle
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage, SystemMessage

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Initialize Bedrock LLM
llm = Bedrock(
    model_id="anthropic.claude-3-sonnet-20240229-v1:0",
    client=bedrock_client,
    model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
)

# Default system prompt
DEFAULT_SYSTEM_PROMPT = "You are Claude, an AI assistant created by Anthropic to be helpful, harmless, and honest."

# Initialize SQLite database
def init_db(conn):
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  system_prompt TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  message TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations (id))''')
    conn.commit()

# Serialization function
def serialize_message(message):
    return pickle.dumps(message)

# Deserialization function
def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation
def create_conversation(conn, name, system_prompt):
    c = conn.cursor()
    c.execute("INSERT INTO conversations (name, system_prompt) VALUES (?, ?)", (name, system_prompt))
    conversation_id = c.lastrowid
    conn.commit()
    return conversation_id

# Function to save a message
def save_message(conn, conversation_id, message):
    c = conn.cursor()
    serialized_message = serialize_message(message)
    c.execute("INSERT INTO messages (conversation_id, message) VALUES (?, ?)",
              (conversation_id, serialized_message))
    conn.commit()

# Function to load messages for a conversation
def load_messages(conn, conversation_id):
    c = conn.cursor()
    c.execute("SELECT message FROM messages WHERE conversation_id = ? ORDER BY created_at", (conversation_id,))
    messages = [deserialize_message(row[0]) for row in c.fetchall()]
    return messages

# Function to get all conversations
def get_conversations(conn):
    c = conn.cursor()
    c.execute("SELECT id, name, system_prompt FROM conversations ORDER BY created_at DESC")
    conversations = c.fetchall()
    return conversations

# Function to get system prompt for a conversation
def get_system_prompt(conn, conversation_id):
    c = conn.cursor()
    c.execute("SELECT system_prompt FROM conversations WHERE id = ?", (conversation_id,))
    result = c.fetchone()
    return result[0] if result else DEFAULT_SYSTEM_PROMPT

# Function to create a new conversation chain
def create_conversation_chain(conn, conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conn, conversation_id)
        memory.chat_memory.messages = messages
        system_prompt = get_system_prompt(conn, conversation_id)
    else:
        system_prompt = DEFAULT_SYSTEM_PROMPT
    
    prompt_template = f"{system_prompt}\n\nCurrent conversation:\n{{history}}\nHuman: {{input}}\nClaude:"
    
    PROMPT = PromptTemplate(
        input_variables=["history", "input"], template=prompt_template
    )
    
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Main Streamlit app
def main():
    # Create a single database connection
    conn = sqlite3.connect('chatbot.db', check_same_thread=False)
    
    # Initialize database
    init_db(conn)

    # Initialize session state
    if 'current_conversation' not in st.session_state:
        st.session_state.current_conversation = None

    # Sidebar for conversation selection
    st.sidebar.title("Conversations")

    # Text input for new conversation label and system prompt
    new_conversation = st.sidebar.text_input("New conversation label")
    new_system_prompt = st.sidebar.text_area("System prompt for new conversation", DEFAULT_SYSTEM_PROMPT)

    if st.sidebar.button("Create New Conversation"):
        if new_conversation:
            conversation_id = create_conversation(conn, new_conversation, new_system_prompt)
            st.session_state.current_conversation = conversation_id
            st.experimental_rerun()

    # Selectbox for existing conversations
    conversations = get_conversations(conn)
    conversation_options = ["New Chat"] + [f"{id}: {name}" for id, name, _ in conversations]
    selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

    if selected_conversation != "New Chat":
        conversation_id = int(selected_conversation.split(":")[0])
        if st.session_state.current_conversation != conversation_id:
            st.session_state.current_conversation = conversation_id

    # Main chat interface
    st.title("Claude 3.5 Sonnet Chatbot")

    # Display current system prompt
    if st.session_state.current_conversation:
        system_prompt = get_system_prompt(conn, st.session_state.current_conversation)
        st.info(f"Current System Prompt: {system_prompt}")

    # Display conversation history
    if st.session_state.current_conversation:
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        for message in chain.memory.chat_memory.messages:
            with st.chat_message(message.type):
                st.write(message.content)

    # Chat input
    user_input = st.chat_input("Type your message here...")

    if user_input:
        # Get or create conversation chain
        if not st.session_state.current_conversation:
            conversation_id = create_conversation(conn, "New Chat", DEFAULT_SYSTEM_PROMPT)
            st.session_state.current_conversation = conversation_id
        
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        
        # Get Claude's response
        response = chain.predict(input=user_input)

        # Display user message and Claude's response
        with st.chat_message("human"):
            st.write(user_input)
        with st.chat_message("ai"):
            st.write(response)

        # Save messages to database
        save_message(conn, st.session_state.current_conversation, HumanMessage(content=user_input))
        save_message(conn, st.session_state.current_conversation, AIMessage(content=response))

    # Close the database connection when the app is done
    conn.close()

# Run the Streamlit app
if __name__ == "__main__":
    main()
```

Here are the key changes and additions:

1. Database Schema: The `conversations` table now includes a `system_prompt` column to store the custom system prompt for each conversation.

2. New Conversation Creation: When creating a new conversation, users can now specify a custom system prompt. If not provided, it uses the default prompt.

3. System Prompt Storage: The `create_conversation` function now takes a `system_prompt` parameter and stores it in the database.

4. System Prompt Retrieval: A new function `get_system_prompt` retrieves the system prompt for a given conversation from the database.

5. Conversation Chain Creation: The `create_conversation_chain` function now incorporates the custom system prompt into the prompt template.

6. User Interface:
   - Added a text area in the sidebar for users to input a custom system prompt when creating a new conversation.
   - Displays the current system prompt for the selected conversation above the chat interface.

7. Default System Prompt: A default system prompt is defined and used when no custom prompt is provided.

These changes allow users to set a custom system prompt for each conversation, which is then stored in the database and used to guide Claude's responses in that specific conversation. The system prompt is displayed in the interface for transparency, and users can create new conversations with different system prompts to explore various interaction styles or specialized knowledge domains.

This implementation provides flexibility in how Claude is instructed for each conversation while maintaining the overall structure and functionality of the chatbot application.

~Add an additional option to select the Bedrock llm model at the time a new conversation is created. The model configuration options should be part of a dropdown menu that is also stored in a table in SQLite, but with an additional button called “Add Model” which will open a dialog box with a Name field, a Configuration text field to accept Bedrock json config inputs (converted to dict in the code for an input to the Bedrock API), a “Proceed” button to confirm the add, and a “Cancel” button to cancel the add operation.
Also add a button labeled “Edit Model” next to the “Add Model” button which opens the same dialog box for the selected model so that the name and configuration text may be edited.~

Certainly! I'll modify the code to include the ability to select and manage Bedrock LLM models. Here's the updated version with the new features:

```python
import streamlit as st
import boto3
import sqlite3
import pickle
import json
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage, SystemMessage

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Default system prompt
DEFAULT_SYSTEM_PROMPT = "You are Claude, an AI assistant created by Anthropic to be helpful, harmless, and honest."

# Initialize SQLite database
def init_db(conn):
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  system_prompt TEXT NOT NULL,
                  model_id INTEGER,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  message TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations (id))''')
    c.execute('''CREATE TABLE IF NOT EXISTS models
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  configuration TEXT NOT NULL)''')
    conn.commit()

# Function to add or edit a model
def add_or_edit_model(conn, name, configuration, model_id=None):
    c = conn.cursor()
    if model_id:
        c.execute("UPDATE models SET name = ?, configuration = ? WHERE id = ?", (name, configuration, model_id))
    else:
        c.execute("INSERT INTO models (name, configuration) VALUES (?, ?)", (name, configuration))
    conn.commit()

# Function to get all models
def get_models(conn):
    c = conn.cursor()
    c.execute("SELECT id, name, configuration FROM models")
    return c.fetchall()

# Function to get model by id
def get_model(conn, model_id):
    c = conn.cursor()
    c.execute("SELECT name, configuration FROM models WHERE id = ?", (model_id,))
    return c.fetchone()

# Function to create a new conversation
def create_conversation(conn, name, system_prompt, model_id):
    c = conn.cursor()
    c.execute("INSERT INTO conversations (name, system_prompt, model_id) VALUES (?, ?, ?)", 
              (name, system_prompt, model_id))
    conversation_id = c.lastrowid
    conn.commit()
    return conversation_id

# Function to save a message
def save_message(conn, conversation_id, message):
    c = conn.cursor()
    serialized_message = serialize_message(message)
    c.execute("INSERT INTO messages (conversation_id, message) VALUES (?, ?)",
              (conversation_id, serialized_message))
    conn.commit()

# Function to load messages for a conversation
def load_messages(conn, conversation_id):
    c = conn.cursor()
    c.execute("SELECT message FROM messages WHERE conversation_id = ? ORDER BY created_at", (conversation_id,))
    messages = [deserialize_message(row[0]) for row in c.fetchall()]
    return messages

# Function to get all conversations
def get_conversations(conn):
    c = conn.cursor()
    c.execute("SELECT id, name, system_prompt, model_id FROM conversations ORDER BY created_at DESC")
    conversations = c.fetchall()
    return conversations

# Function to get system prompt and model for a conversation
def get_conversation_details(conn, conversation_id):
    c = conn.cursor()
    c.execute("SELECT system_prompt, model_id FROM conversations WHERE id = ?", (conversation_id,))
    result = c.fetchone()
    return result if result else (DEFAULT_SYSTEM_PROMPT, None)

# Serialization and deserialization functions (unchanged)
def serialize_message(message):
    return pickle.dumps(message)

def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation chain
def create_conversation_chain(conn, conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conn, conversation_id)
        memory.chat_memory.messages = messages
        system_prompt, model_id = get_conversation_details(conn, conversation_id)
        if model_id:
            model_name, model_config = get_model(conn, model_id)
            llm = Bedrock(
                model_id=model_name,
                client=bedrock_client,
                model_kwargs=json.loads(model_config)
            )
        else:
            llm = Bedrock(
                model_id="anthropic.claude-3-sonnet-20240229-v1:0",
                client=bedrock_client,
                model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
            )
    else:
        system_prompt = DEFAULT_SYSTEM_PROMPT
        llm = Bedrock(
            model_id="anthropic.claude-3-sonnet-20240229-v1:0",
            client=bedrock_client,
            model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
        )
    
    prompt_template = f"{system_prompt}\n\nCurrent conversation:\n{{history}}\nHuman: {{input}}\nClaude:"
    
    PROMPT = PromptTemplate(
        input_variables=["history", "input"], template=prompt_template
    )
    
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Main Streamlit app
def main():
    # Create a single database connection
    conn = sqlite3.connect('chatbot.db', check_same_thread=False)
    
    # Initialize database
    init_db(conn)

    # Initialize session state
    if 'current_conversation' not in st.session_state:
        st.session_state.current_conversation = None

    # Sidebar for conversation selection and model management
    st.sidebar.title("Conversations and Models")

    # Model management
    st.sidebar.subheader("Model Management")
    models = get_models(conn)
    model_names = [model[1] for model in models]
    selected_model = st.sidebar.selectbox("Select Model", [""] + model_names)

    col1, col2 = st.sidebar.columns(2)
    if col1.button("Add Model"):
        st.session_state.add_model = True
    if col2.button("Edit Model"):
        if selected_model:
            st.session_state.edit_model = True
        else:
            st.sidebar.warning("Please select a model to edit.")

    # Add Model dialog
    if 'add_model' in st.session_state and st.session_state.add_model:
        with st.sidebar.form("add_model_form"):
            st.subheader("Add New Model")
            new_model_name = st.text_input("Model Name")
            new_model_config = st.text_area("Model Configuration (JSON)")
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(new_model_config)  # Validate JSON
                    add_or_edit_model(conn, new_model_name, new_model_config)
                    st.success("Model added successfully!")
                    st.session_state.add_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.add_model = False
                st.experimental_rerun()

    # Edit Model dialog
    if 'edit_model' in st.session_state and st.session_state.edit_model:
        with st.sidebar.form("edit_model_form"):
            st.subheader("Edit Model")
            model_to_edit = [model for model in models if model[1] == selected_model][0]
            edit_model_name = st.text_input("Model Name", value=model_to_edit[1])
            edit_model_config = st.text_area("Model Configuration (JSON)", value=model_to_edit[2])
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(edit_model_config)  # Validate JSON
                    add_or_edit_model(conn, edit_model_name, edit_model_config, model_to_edit[0])
                    st.success("Model updated successfully!")
                    st.session_state.edit_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.edit_model = False
                st.experimental_rerun()

    # New conversation creation
    st.sidebar.subheader("Create New Conversation")
    new_conversation = st.sidebar.text_input("New conversation label")
    new_system_prompt = st.sidebar.text_area("System prompt for new conversation", DEFAULT_SYSTEM_PROMPT)
    new_conversation_model = st.sidebar.selectbox("Model for new conversation", model_names)

    if st.sidebar.button("Create New Conversation"):
        if new_conversation and new_conversation_model:
            model_id = [model[0] for model in models if model[1] == new_conversation_model][0]
            conversation_id = create_conversation(conn, new_conversation, new_system_prompt, model_id)
            st.session_state.current_conversation = conversation_id
            st.experimental_rerun()
        else:
            st.sidebar.warning("Please provide a conversation name and select a model.")

    # Existing conversation selection
    st.sidebar.subheader("Select Existing Conversation")
    conversations = get_conversations(conn)
    conversation_options = ["New Chat"] + [f"{id}: {name}" for id, name, _, _ in conversations]
    selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

    if selected_conversation != "New Chat":
        conversation_id = int(selected_conversation.split(":")[0])
        if st.session_state.current_conversation != conversation_id:
            st.session_state.current_conversation = conversation_id

    # Main chat interface
    st.title("Claude 3.5 Sonnet Chatbot")

    # Display current system prompt and model
    if st.session_state.current_conversation:
        system_prompt, model_id = get_conversation_details(conn, st.session_state.current_conversation)
        model_name = get_model(conn, model_id)[0] if model_id else "Default"
        st.info(f"Current System Prompt: {system_prompt}")
        st.info(f"Current Model: {model_name}")

    # Display conversation history
    if st.session_state.current_conversation:
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        for message in chain.memory.chat_memory.messages:
            with st.chat_message(message.type):
                st.write(message.content)

    # Chat input
    user_input = st.chat_input("Type your message here...")

    if user_input:
        # Get or create conversation chain
        if not st.session_state.current_conversation:
            st.warning("Please create or select a conversation before chatting.")
        else:
            chain = create_conversation_chain(conn, st.session_state.current_conversation)
            
            # Get Claude's response
            response = chain.predict(input=user_input)

            # Display user message and Claude's response
            with st.chat_message("human"):
                st.write(user_input)
            with st.chat_message("ai"):
                st.write(response)

            # Save messages to database
            save_message(conn, st.session_state.current_conversation, HumanMessage(content=user_input))
            save_message(conn, st.session_state.current_conversation, AIMessage(content=response))

    # Close the database connection when the app is done
    conn.close()

# Run the Streamlit app
if __name__ == "__main__":
    main()
```

This updated version includes the following new features and changes:

1. Model Management:
   - A new `models` table in the SQLite database to store model configurations.
   - Functions to add, edit, and retrieve models from the database.
   - A dropdown menu in the sidebar to select models.
   - "Add Model" and "Edit Model" buttons that open dialog boxes for managing models.

2. Model Selection for New Conversations:
   - When creating a new conversation, users can now select a model from the dropdown menu.
   - The selected model is stored with the conversation in the database.

3. Dynamic Model Loading:
   - The `create_conversation_chain` function now loads the appropriate model for each conversation based on the stored model ID.

4. User Interface Updates:
   - The sidebar now includes sections for model management and conversation creation/selection.
   - Dialog boxes for adding and editing models, with JSON validation for the configuration.
   - Display of the current model alongside the system prompt for each conversation.

5. Error Handling and Validation:
   - JSON validation for model configurations to ensure they are valid before saving.
   - Warnings and error messages for various user actions.

This implementation allows users to manage multiple Bedrock LLM models, associate them with specific conversations, and dynamically load the appropriate model for each chat interaction. The model configurations are stored in the database, allowing for easy management and updates.

To use this updated version:

1. Users can add new models using the "Add Model" button, providing a name and JSON configuration.
2. Existing models can be edited using the "Edit Model" button after selecting a model from the dropdown.
3. When creating a new conversation, users can select a model from the dropdown menu.
4. The selected model will be used for all interactions within that conversation.

This setup provides a flexible and user-friendly way to manage multiple LLM models and use them in different conversations within the chatbot application.

~Using this page info as a reference - https://docs.streamlit.io/develop/concepts/connections/connecting-to-data - change the database setup on the app to use SQLAlchemy and the Streamlit example at the url.~

Certainly! I'll modify the application to use SQLAlchemy with Streamlit's `st.connection` for database management. This approach will leverage Streamlit's connection capabilities and provide a more streamlined database interaction. Here's the updated version of the code:

```python
import streamlit as st
import boto3
import pickle
import json
from sqlalchemy import create_engine, Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.sql import func
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Default system prompt
DEFAULT_SYSTEM_PROMPT = "You are Claude, an AI assistant created by Anthropic to be helpful, harmless, and honest."

# SQLAlchemy setup
Base = declarative_base()

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    system_prompt = Column(String, nullable=False)
    model_id = Column(Integer, ForeignKey('models.id'))
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    conversation_id = Column(Integer, ForeignKey('conversations.id'))
    message = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Model(Base):
    __tablename__ = 'models'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    configuration = Column(String, nullable=False)

# Streamlit database connection
@st.cache_resource
def init_connection():
    return st.connection('sqlite', type='sql', url="sqlite:///chatbot.db")

# Initialize database
def init_db(conn):
    engine = create_engine(conn.url)
    Base.metadata.create_all(engine)

# Function to add or edit a model
def add_or_edit_model(conn, name, configuration, model_id=None):
    with conn.session as session:
        if model_id:
            model = session.query(Model).filter_by(id=model_id).first()
            model.name = name
            model.configuration = configuration
        else:
            new_model = Model(name=name, configuration=configuration)
            session.add(new_model)
        session.commit()

# Function to get all models
def get_models(conn):
    with conn.session as session:
        return session.query(Model).all()

# Function to get model by id
def get_model(conn, model_id):
    with conn.session as session:
        model = session.query(Model).filter_by(id=model_id).first()
        return model.name, model.configuration if model else (None, None)

# Function to create a new conversation
def create_conversation(conn, name, system_prompt, model_id):
    with conn.session as session:
        new_conversation = Conversation(name=name, system_prompt=system_prompt, model_id=model_id)
        session.add(new_conversation)
        session.commit()
        return new_conversation.id

# Function to save a message
def save_message(conn, conversation_id, message):
    with conn.session as session:
        serialized_message = serialize_message(message)
        new_message = Message(conversation_id=conversation_id, message=serialized_message)
        session.add(new_message)
        session.commit()

# Function to load messages for a conversation
def load_messages(conn, conversation_id):
    with conn.session as session:
        messages = session.query(Message).filter_by(conversation_id=conversation_id).order_by(Message.created_at).all()
        return [deserialize_message(message.message) for message in messages]

# Function to get all conversations
def get_conversations(conn):
    with conn.session as session:
        return session.query(Conversation).order_by(Conversation.created_at.desc()).all()

# Function to get system prompt and model for a conversation
def get_conversation_details(conn, conversation_id):
    with conn.session as session:
        conversation = session.query(Conversation).filter_by(id=conversation_id).first()
        return (conversation.system_prompt, conversation.model_id) if conversation else (DEFAULT_SYSTEM_PROMPT, None)

# Serialization and deserialization functions (unchanged)
def serialize_message(message):
    return pickle.dumps(message)

def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation chain
def create_conversation_chain(conn, conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conn, conversation_id)
        memory.chat_memory.messages = messages
        system_prompt, model_id = get_conversation_details(conn, conversation_id)
        if model_id:
            model_name, model_config = get_model(conn, model_id)
            llm = Bedrock(
                model_id=model_name,
                client=bedrock_client,
                model_kwargs=json.loads(model_config)
            )
        else:
            llm = Bedrock(
                model_id="anthropic.claude-3-sonnet-20240229-v1:0",
                client=bedrock_client,
                model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
            )
    else:
        system_prompt = DEFAULT_SYSTEM_PROMPT
        llm = Bedrock(
            model_id="anthropic.claude-3-sonnet-20240229-v1:0",
            client=bedrock_client,
            model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
        )
    
    prompt_template = f"{system_prompt}\n\nCurrent conversation:\n{{history}}\nHuman: {{input}}\nClaude:"
    
    PROMPT = PromptTemplate(
        input_variables=["history", "input"], template=prompt_template
    )
    
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Main Streamlit app
def main():
    # Initialize database connection
    conn = init_connection()
    init_db(conn)

    # Initialize session state
    if 'current_conversation' not in st.session_state:
        st.session_state.current_conversation = None

    # Sidebar for conversation selection and model management
    st.sidebar.title("Conversations and Models")

    # Model management
    st.sidebar.subheader("Model Management")
    models = get_models(conn)
    model_names = [model.name for model in models]
    selected_model = st.sidebar.selectbox("Select Model", [""] + model_names)

    col1, col2 = st.sidebar.columns(2)
    if col1.button("Add Model"):
        st.session_state.add_model = True
    if col2.button("Edit Model"):
        if selected_model:
            st.session_state.edit_model = True
        else:
            st.sidebar.warning("Please select a model to edit.")

    # Add Model dialog
    if 'add_model' in st.session_state and st.session_state.add_model:
        with st.sidebar.form("add_model_form"):
            st.subheader("Add New Model")
            new_model_name = st.text_input("Model Name")
            new_model_config = st.text_area("Model Configuration (JSON)")
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(new_model_config)  # Validate JSON
                    add_or_edit_model(conn, new_model_name, new_model_config)
                    st.success("Model added successfully!")
                    st.session_state.add_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.add_model = False
                st.experimental_rerun()

    # Edit Model dialog
    if 'edit_model' in st.session_state and st.session_state.edit_model:
        with st.sidebar.form("edit_model_form"):
            st.subheader("Edit Model")
            model_to_edit = next(model for model in models if model.name == selected_model)
            edit_model_name = st.text_input("Model Name", value=model_to_edit.name)
            edit_model_config = st.text_area("Model Configuration (JSON)", value=model_to_edit.configuration)
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(edit_model_config)  # Validate JSON
                    add_or_edit_model(conn, edit_model_name, edit_model_config, model_to_edit.id)
                    st.success("Model updated successfully!")
                    st.session_state.edit_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.edit_model = False
                st.experimental_rerun()

    # New conversation creation
    st.sidebar.subheader("Create New Conversation")
    new_conversation = st.sidebar.text_input("New conversation label")
    new_system_prompt = st.sidebar.text_area("System prompt for new conversation", DEFAULT_SYSTEM_PROMPT)
    new_conversation_model = st.sidebar.selectbox("Model for new conversation", model_names)

    if st.sidebar.button("Create New Conversation"):
        if new_conversation and new_conversation_model:
            model_id = next(model.id for model in models if model.name == new_conversation_model)
            conversation_id = create_conversation(conn, new_conversation, new_system_prompt, model_id)
            st.session_state.current_conversation = conversation_id
            st.experimental_rerun()
        else:
            st.sidebar.warning("Please provide a conversation name and select a model.")

    # Existing conversation selection
    st.sidebar.subheader("Select Existing Conversation")
    conversations = get_conversations(conn)
    conversation_options = ["New Chat"] + [f"{conv.id}: {conv.name}" for conv in conversations]
    selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

    if selected_conversation != "New Chat":
        conversation_id = int(selected_conversation.split(":")[0])
        if st.session_state.current_conversation != conversation_id:
            st.session_state.current_conversation = conversation_id

    # Main chat interface
    st.title("Claude 3.5 Sonnet Chatbot")

    # Display current system prompt and model
    if st.session_state.current_conversation:
        system_prompt, model_id = get_conversation_details(conn, st.session_state.current_conversation)
        model_name, _ = get_model(conn, model_id) if model_id else (None, None)
        model_name = model_name or "Default"
        st.info(f"Current System Prompt: {system_prompt}")
        st.info(f"Current Model: {model_name}")

    # Display conversation history
    if st.session_state.current_conversation:
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        for message in chain.memory.chat_memory.messages:
            with st.chat_message(message.type):
                st.write(message.content)

    # Chat input
    user_input = st.chat_input("Type your message here...")

    if user_input:
        # Get or create conversation chain
        if not st.session_state.current_conversation:
            st.warning("Please create or select a conversation before chatting.")
        else:
            chain = create_conversation_chain(conn, st.session_state.current_conversation)
            
            # Get Claude's response
            response = chain.predict(input=user_input)

            # Display user message and Claude's response
            with st.chat_message("human"):
                st.write(user_input)
            with st.chat_message("ai"):
                st.write(response)

            # Save messages to database
            save_message(conn, st.session_state.current_conversation, HumanMessage(content=user_input))
            save_message(conn, st.session_state.current_conversation, AIMessage(content=response))

# Run the Streamlit app
if __name__ == "__main__":
    main()
```

This updated version of the code incorporates SQLAlchemy and Streamlit's `st.connection` for database management. Here are the key changes and benefits:

1. SQLAlchemy Models: We've defined SQLAlchemy models (`Conversation`, `Message`, and `Model`) to represent our database tables.

2. Streamlit Connection: We use `st.connection` to create a SQLite connection that's cached and reusable across Streamlit reruns.

3. Database Initialization: The `init_db` function now uses SQLAlchemy to create tables if they don't exist.

4. Session Management: We use SQLAlchemy's session management within each database operation, utilizing Streamlit's connection context manager.

5. Query Simplification: SQLAlchemy allows for more Pythonic and type-safe queries.

6. Connection Reuse: The Streamlit connection is initialized once and reused throughout the application, improving performance.

7. Type Safety: SQLAlchemy provides better type checking and validation for database operations.

8. Easier Migration: If you need to switch to a different database system in the future, SQLAlchemy makes it easier to migrate.

To use this updated version:

1. Make sure you have SQLAlchemy installed (`pip install sqlalchemy`).
2. The application will automatically create and use a SQLite database file named `chatbot.db` in the same directory as the script.
3. The rest of the functionality remains the same as in the previous version.

This implementation provides a more robust and maintainable database interaction layer while keeping the core functionality of the chatbot application intact. It leverages Streamlit's connection capabilities for efficient database access and SQLAlchemy for improved data modeling and querying.

~Using this page info as a reference - https://docs.streamlit.io/develop/concepts/connections/connecting-to-data - change the database setup on the app to use SQLAlchemy and the Streamlit example at the url.~

I apologize for the confusion in my previous response. You're right to point out that I didn't fully implement the Streamlit connection example from the provided URL. Let's modify the code to more closely follow the Streamlit example for SQLAlchemy connections. Here's the updated version:

```python
import streamlit as st
import boto3
import pickle
import json
from sqlalchemy import create_engine, Column, Integer, String, DateTime, ForeignKey, select
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.sql import func
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
from langchain.llms.bedrock import Bedrock
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage, AIMessage

# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime')

# Default system prompt
DEFAULT_SYSTEM_PROMPT = "You are Claude, an AI assistant created by Anthropic to be helpful, harmless, and honest."

# SQLAlchemy setup
Base = declarative_base()

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    system_prompt = Column(String, nullable=False)
    model_id = Column(Integer, ForeignKey('models.id'))
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    conversation_id = Column(Integer, ForeignKey('conversations.id'))
    message = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Model(Base):
    __tablename__ = 'models'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    configuration = Column(String, nullable=False)

# Streamlit SQLAlchemy connection
class SQLAlchemyConnection(st.connection):
    def __init__(self, url: str, **kwargs):
        super().__init__(**kwargs)
        self._url = url
        self._engine = None

    def _connect(self):
        self._engine = create_engine(self._url)
        Base.metadata.create_all(self._engine)
        return sessionmaker(bind=self._engine)

    def query(self, query, **kwargs):
        Session = self._instance
        with Session() as session:
            result = session.execute(query, kwargs)
            return result.fetchall()

    def add(self, obj):
        Session = self._instance
        with Session() as session:
            session.add(obj)
            session.commit()

    def update(self, obj):
        Session = self._instance
        with Session() as session:
            session.merge(obj)
            session.commit()

# Initialize database connection
@st.cache_resource
def init_connection():
    return SQLAlchemyConnection("sqlite:///chatbot.db")

# Function to add or edit a model
def add_or_edit_model(conn, name, configuration, model_id=None):
    if model_id:
        model = conn.query(select(Model).filter_by(id=model_id))[0]
        model.name = name
        model.configuration = configuration
        conn.update(model)
    else:
        new_model = Model(name=name, configuration=configuration)
        conn.add(new_model)

# Function to get all models
def get_models(conn):
    return conn.query(select(Model))

# Function to get model by id
def get_model(conn, model_id):
    result = conn.query(select(Model).filter_by(id=model_id))
    if result:
        model = result[0]
        return model.name, model.configuration
    return None, None

# Function to create a new conversation
def create_conversation(conn, name, system_prompt, model_id):
    new_conversation = Conversation(name=name, system_prompt=system_prompt, model_id=model_id)
    conn.add(new_conversation)
    return new_conversation.id

# Function to save a message
def save_message(conn, conversation_id, message):
    serialized_message = serialize_message(message)
    new_message = Message(conversation_id=conversation_id, message=serialized_message)
    conn.add(new_message)

# Function to load messages for a conversation
def load_messages(conn, conversation_id):
    messages = conn.query(select(Message).filter_by(conversation_id=conversation_id).order_by(Message.created_at))
    return [deserialize_message(message.message) for message in messages]

# Function to get all conversations
def get_conversations(conn):
    return conn.query(select(Conversation).order_by(Conversation.created_at.desc()))

# Function to get system prompt and model for a conversation
def get_conversation_details(conn, conversation_id):
    result = conn.query(select(Conversation).filter_by(id=conversation_id))
    if result:
        conversation = result[0]
        return conversation.system_prompt, conversation.model_id
    return DEFAULT_SYSTEM_PROMPT, None

# Serialization and deserialization functions (unchanged)
def serialize_message(message):
    return pickle.dumps(message)

def deserialize_message(serialized_message):
    return pickle.loads(serialized_message)

# Function to create a new conversation chain
def create_conversation_chain(conn, conversation_id=None):
    memory = ConversationBufferMemory(return_messages=True)
    if conversation_id:
        messages = load_messages(conn, conversation_id)
        memory.chat_memory.messages = messages
        system_prompt, model_id = get_conversation_details(conn, conversation_id)
        if model_id:
            model_name, model_config = get_model(conn, model_id)
            llm = Bedrock(
                model_id=model_name,
                client=bedrock_client,
                model_kwargs=json.loads(model_config)
            )
        else:
            llm = Bedrock(
                model_id="anthropic.claude-3-sonnet-20240229-v1:0",
                client=bedrock_client,
                model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
            )
    else:
        system_prompt = DEFAULT_SYSTEM_PROMPT
        llm = Bedrock(
            model_id="anthropic.claude-3-sonnet-20240229-v1:0",
            client=bedrock_client,
            model_kwargs={"max_tokens_to_sample": 500, "temperature": 0.7}
        )
    
    prompt_template = f"{system_prompt}\n\nCurrent conversation:\n{{history}}\nHuman: {{input}}\nClaude:"
    
    PROMPT = PromptTemplate(
        input_variables=["history", "input"], template=prompt_template
    )
    
    return ConversationChain(
        llm=llm,
        memory=memory,
        prompt=PROMPT
    )

# Main Streamlit app
def main():
    # Initialize database connection
    conn = init_connection()

    # Initialize session state
    if 'current_conversation' not in st.session_state:
        st.session_state.current_conversation = None

    # Sidebar for conversation selection and model management
    st.sidebar.title("Conversations and Models")

    # Model management
    st.sidebar.subheader("Model Management")
    models = get_models(conn)
    model_names = [model.name for model in models]
    selected_model = st.sidebar.selectbox("Select Model", [""] + model_names)

    col1, col2 = st.sidebar.columns(2)
    if col1.button("Add Model"):
        st.session_state.add_model = True
    if col2.button("Edit Model"):
        if selected_model:
            st.session_state.edit_model = True
        else:
            st.sidebar.warning("Please select a model to edit.")

    # Add Model dialog
    if 'add_model' in st.session_state and st.session_state.add_model:
        with st.sidebar.form("add_model_form"):
            st.subheader("Add New Model")
            new_model_name = st.text_input("Model Name")
            new_model_config = st.text_area("Model Configuration (JSON)")
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(new_model_config)  # Validate JSON
                    add_or_edit_model(conn, new_model_name, new_model_config)
                    st.success("Model added successfully!")
                    st.session_state.add_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.add_model = False
                st.experimental_rerun()

    # Edit Model dialog
    if 'edit_model' in st.session_state and st.session_state.edit_model:
        with st.sidebar.form("edit_model_form"):
            st.subheader("Edit Model")
            model_to_edit = next(model for model in models if model.name == selected_model)
            edit_model_name = st.text_input("Model Name", value=model_to_edit.name)
            edit_model_config = st.text_area("Model Configuration (JSON)", value=model_to_edit.configuration)
            submitted = st.form_submit_button("Proceed")
            if submitted:
                try:
                    json.loads(edit_model_config)  # Validate JSON
                    add_or_edit_model(conn, edit_model_name, edit_model_config, model_to_edit.id)
                    st.success("Model updated successfully!")
                    st.session_state.edit_model = False
                    st.experimental_rerun()
                except json.JSONDecodeError:
                    st.error("Invalid JSON configuration. Please check and try again.")
            if st.form_submit_button("Cancel"):
                st.session_state.edit_model = False
                st.experimental_rerun()

    # New conversation creation
    st.sidebar.subheader("Create New Conversation")
    new_conversation = st.sidebar.text_input("New conversation label")
    new_system_prompt = st.sidebar.text_area("System prompt for new conversation", DEFAULT_SYSTEM_PROMPT)
    new_conversation_model = st.sidebar.selectbox("Model for new conversation", model_names)

    if st.sidebar.button("Create New Conversation"):
        if new_conversation and new_conversation_model:
            model_id = next(model.id for model in models if model.name == new_conversation_model)
            conversation_id = create_conversation(conn, new_conversation, new_system_prompt, model_id)
            st.session_state.current_conversation = conversation_id
            st.experimental_rerun()
        else:
            st.sidebar.warning("Please provide a conversation name and select a model.")

    # Existing conversation selection
    st.sidebar.subheader("Select Existing Conversation")
    conversations = get_conversations(conn)
    conversation_options = ["New Chat"] + [f"{conv.id}: {conv.name}" for conv in conversations]
    selected_conversation = st.sidebar.selectbox("Select a conversation", conversation_options)

    if selected_conversation != "New Chat":
        conversation_id = int(selected_conversation.split(":")[0])
        if st.session_state.current_conversation != conversation_id:
            st.session_state.current_conversation = conversation_id

    # Main chat interface
    st.title("Claude 3.5 Sonnet Chatbot")

    # Display current system prompt and model
    if st.session_state.current_conversation:
        system_prompt, model_id = get_conversation_details(conn, st.session_state.current_conversation)
        model_name, _ = get_model(conn, model_id) if model_id else (None, None)
        model_name = model_name or "Default"
        st.info(f"Current System Prompt: {system_prompt}")
        st.info(f"Current Model: {model_name}")

    # Display conversation history
    if st.session_state.current_conversation:
        chain = create_conversation_chain(conn, st.session_state.current_conversation)
        for message in chain.memory.chat_memory.messages:
            with st.chat_message(message.type):
                st.write(message.content)

    # Chat input
    user_input = st.chat_input("Type your message here...")

    if user_input:
        # Get or create conversation chain
        if not st.session_state.current_conversation:
            st.warning("Please create or select a conversation before chatting.")
        else:
            chain = create_conversation_chain(conn, st.session_state.current_conversation)
            
            # Get Claude's response
            response = chain.predict(input=user_input)

            # Display user message and Claude's response
            with st.chat_message("human"):
                st.write(user_input)
            with st.chat_message("ai"):
                st.write(response)

            # Save messages to database
            save_message(conn, st.session_state.current_conversation, HumanMessage(content=user_input))
            save_message(conn, st.session_state.current_conversation, AIMessage(content=response))

# Run the Streamlit app
if __name__ == "__main__":
    main()
```

This version of the code more closely follows the Streamlit example for SQLAlchemy connections. Here are the key changes:

1. Custom Connection Class: We've created a `SQLAlchemyConnection` class that extends `st.connection`. This class handles the connection to the database and provides methods for querying and modifying data.

2. Connection Initialization: The `init_connection` function now returns an instance of our custom `SQLAlchemyConnection` class.

3. Query Method: The `query` method in our custom connection class executes SQL queries using SQLAlchemy's `select` function.

4. Add and Update Methods: We've added `add` and `update` methods to our custom connection class to handle inserting and updating records.

5. Database Operations: All database operations now use the methods provided by our custom connection class.

This implementation provides several benefits:

1. Better Integration with Streamlit: By using `st.connection`, we're leveraging Streamlit's built-in caching and connection management.

2. Simplified Query Interface: The `query` method provides a simple interface for executing SQL queries.

3. Consistency with Streamlit Examples: This implementation is more in line with Streamlit's recommended practices for database connections.

4. Improved Connection Management: Streamlit handles the lifecycle of the database connection, ensuring it's properly opened and closed.

To use this updated version:

1. Ensure you have the required libraries installed (`streamlit`, `sqlalchemy`, `boto3`, etc.).
2. Run the script using `streamlit run your_script_name.py`.
3. The application will create and use a SQLite database file named `chatbot.db` in the same directory as the script.

This implementation provides a more Streamlit-friendly approach to database management while maintaining the core functionality of the chatbot application.
